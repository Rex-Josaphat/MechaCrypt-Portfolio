[
  {
    "objectID": "pages/team.html",
    "href": "pages/team.html",
    "title": "Meet The Developers",
    "section": "",
    "text": "Josaphat Ngoga\n\n\n\n\n\nJosaphat Ngoga is a senior Engineering major at Harvey Mudd College. His interests span both Mechanical and Electrical engineering, with a focus and experience in mechanical design, electronics, control systems and hardware systems. He enjoys working on projects that bring these areas together, especially those involving mechanical systems, FPGA development, embedded systems and circuit design. During his internships at UL Solutions, he also gained experience in DSP and RF/Wireless systems.\n\n\n  \n    \n    Website\n  \n\n  \n    \n    LinkedIn\n  \n\n  \n    \n    E155 Portfolio\n  \n\n  \n    \n    GitHub\n  \n\n\n\n\n\n\nChristian Wu\n\n\n\n\n\nChristian Wu is a Junior at Harvey Mudd College studying Engineering, with a passion for digital electronics and hardware engineering. Christian grew up in Santiago, Chile, until he moved to the United States to attend Harvey Mudd College. His professional experience includes being a manufacturing engineering intern at Johnson & Johnson and General Motors. Christian is a Machine Shop Proctor at Harvey Mudd and enjoys playing basketball in his time off.\n\n\n  \n    \n    LinkedIn\n  \n\n  \n    \n    E155 Portfolio\n  \n\n  \n    \n    GitHub"
  },
  {
    "objectID": "pages/mcu.html",
    "href": "pages/mcu.html",
    "title": "MCU Design",
    "section": "",
    "text": "This project consists of two MCUs, one for the sender end, and one for the receiver end. For each MCU, we will describe each peripheral that we integrate it, how communication is established with the MCU, and what data is sent."
  },
  {
    "objectID": "pages/mcu.html#introduction",
    "href": "pages/mcu.html#introduction",
    "title": "MCU Design",
    "section": "",
    "text": "This project consists of two MCUs, one for the sender end, and one for the receiver end. For each MCU, we will describe each peripheral that we integrate it, how communication is established with the MCU, and what data is sent."
  },
  {
    "objectID": "pages/mcu.html#sender-mcu-design",
    "href": "pages/mcu.html#sender-mcu-design",
    "title": "MCU Design",
    "section": "Sender MCU Design",
    "text": "Sender MCU Design\nFor the sender MCU, it will utilize TRNG to generate random keys, it will connect to the sender FPGA where encryption occurs and it will be connected to a ESP8266 where user inputs occur. Below, we will describe in detail how this was implemented.\n\nTRNG Implementation\nThe STM32L432KC MCU has a built in True Random Number Generator (TRNG). The TRNG generates 32 random bits, so we need to read it four times to generate 128 random bits, which equates to a random key that is used for AES-128 encryption. The code is designed so that when the sender sends a message over the website UI, the website calculates how many 128 bit blocks are required to send over the message. The MCU code will then generate a random 128 bit key for each of the message blocks and store it on an array in the MCU to be sent to the sender and receiver FPGA.\n\n\nConnection with Sender FPGA\nThe STM32 MCU interacts with the sender FPGA via SPI, which is the same as the way it was set up in lab 7. The data that is sent over to the FPGA is the plaintext and its randomly generated key. Given that our system is built to be able to send multiple 128 bit blocks, we need to know when the FPGA has encrypted a block and is ready to receive the next block and encrypt it. This is achieved by the FPGA sending a done signal to the MCU so that the MCU will send over the next set of plaintext and key. The very first block sending of the program is triggered by the user when hitting the send button on the website, all subsequent block sending is based on the done signal sent by the FPGA.\nIn terms of hardware, in order to save pins, we will be using the same output pins for the SPI connections between the MCU and both the sender and receiver FPGA. In other words, it means that SCK, COPI, and CIPO are the same MCU pins wired to both FPGAs. In order for the two FPGAs to not read the wrong data, we have a separate chip enable wire going to each of the FPGAs. That way, each FPGA knows when the data sent over SPI is meant for it.\n\n\nESP8266 Integration\nThe sender MCU uses an ESP8266 for its messaging UI for both the sender and receiver. THe MCU and ESP8266 connect via USART, which is the same as we have done with previous labs. On the sender side, the user will input their desired message. They can then click the convert button, which will show them how many blocks of data are gonna be sent, as well as the data that will be sent. The data will be in hex, which is the ASCII equivalent of the text in hex form, which is what we need to input into the FPGA. Since the FPGA uses AES-128 encryption, we need to ensure that each block of text is 128 bits long, even if the message is not that long. To do this, we can use padding, which will fill the remainder of the 128 bit block. We used PKCS #7 padding, which will fill in the remainding bytes needed in the block with the number of bytes that it is filling in. 128 bit blocks are equivalent to 16 bytes, so if we only use 8 bytes worth of text in the block, it will fill the remaining 8 bytes with 0x08. Then, the user can click send, which will start the whole sending transaction for the system. Below is a sample image of what the website UI looks like for the user:\n\n\n\nSample Sender Website UI"
  },
  {
    "objectID": "pages/mcu.html#receiver-mcu-design",
    "href": "pages/mcu.html#receiver-mcu-design",
    "title": "MCU Design",
    "section": "Receiver MCU Design",
    "text": "Receiver MCU Design\nFor the receiver MCU, it connects with the receiver FPGA for decryption, it connects with the ESP8266 for the receiver end website, it connects with the mechanical actuation system to receive the encrypted ciphertext, and it connects with an LCD display to show live progress of the message transfer.\n\nConnection with Receiver FPGA\nThe receiver MCU interacts with the receiver FPGA via SPI, which is the same as the way it was set up in lab 7. The FPGA will send the decypted plaintext to the MCU via SPI.\n\n\nESP8266 Integration\nThe receiver end ESP8266 displays the decrypted text to the receiver end user, which should match what the sender sent originally. Given that the mechanical system takes a while to send the data, the receiver end website will display one block at a time until all the blocks have arrived to the receiver side and have been decrypted. The receiver end website UI is built to be similar to the sender UI to demonstrate that encryption and decryption worked correctly, showing each individual 128-bit block of data as well as the full message. Below is a sample image of what the receiver end website UI looks like for the user:\n\n\n\nSample Receiver Website UI\n\n\n\n\nLCD Display Integration\nIn order to track how much data has been sent over and how close we are to the full message transaction being complete, we have implemented the use of an LCD Display. We purchased an LCD Display with an I2C adapter, meaning that it will only require 2 MCU pins instead of 8. This saves up a lot of pins, given that the MCU also needs to connect to the ESP8266, the receiver FPGA, and the mechanical actuation system. To drive the LCD display and the I2C adapter, we need a 5V source, which is provided by our motherboard. For the I2C adapter to register a high value, it needs at least \\(0.7 V_{DD}\\), which is 3.5 V. However, our STM32 pins only output 3.3 V. Thus, we need to use a level shifter, so that the I2C adapter can properly read low and high values. Below is a schematic of our level shifter implementation for our display:\n\n\n\nSchematic for LCD Display with 3.3 V to 5 V Level Shifter\n\n\nTo run the actual display, we were able to use files provided by the manufacturer, which had functions made to control the display. However, this file was in C++, so we had to convert it to C. Once that was done, we were able to initialize I2C on our MCU and display a progress bar on our display. Below is a video demonstrating what the progress tracking would look like:\n\n\nVideo\nLCD Progress Demo"
  },
  {
    "objectID": "pages/fpga.html",
    "href": "pages/fpga.html",
    "title": "FPGA Design",
    "section": "",
    "text": "This project consists of two FPGAs, one for the sender end, and one for the receiver end. For each FPGA we describe the different modules involved, how they influence and affect the system overall and describe any connections between the FPGAs and either of the MCUs"
  },
  {
    "objectID": "pages/fpga.html#introduction",
    "href": "pages/fpga.html#introduction",
    "title": "FPGA Design",
    "section": "",
    "text": "This project consists of two FPGAs, one for the sender end, and one for the receiver end. For each FPGA we describe the different modules involved, how they influence and affect the system overall and describe any connections between the FPGAs and either of the MCUs"
  },
  {
    "objectID": "pages/fpga.html#sender-fpga-design",
    "href": "pages/fpga.html#sender-fpga-design",
    "title": "FPGA Design",
    "section": "Sender FPGA Design",
    "text": "Sender FPGA Design\nThe main goal of the sender FPGA was to receive data from the MCU, encrypt it and proceed to send it over by triggering the merchanical system effectively. All relevant modules are described in the chapters below.\n\nAES Encryption Module\nThis module talks to the MCU via SPI. The MCU communicates to this module by sending a chipselect signal that prepares this module to receive the plaintext and the generated key. The SPI implementation on the FPGA is a shift register that continously shifts data in from the MCU MOSI or out through the MCU MISO. The module also proceeds to encrypt the given ciphertext and will return the ciphertext, the key, and a signal, done, indicating that encryption is completed. Information about encryption can be found in AES Encryption Overview webpage.\n\n\nSPRAM Implementation\nWe implemented on-chip SPRAM (Single-Port RAM) to temporarily store the ciphertext within the FPGA, effectively reducing reliance on and potential exhaustion of other limited on-board memory resources. SPRAM offers fast access speeds and a straightforward interface for both read and write operations. Lattice provides the dedicated hardware macro SB_SPRAM256KA for this purpose, enabling efficient data buffering between the AES core and the external communication modules. Each iCE40UP5K FPGA includes four SPRAM blocks, each providing 16K × 16 bits (256 Kb) of storage. This translates to a total of 1 Mbit (128 KB) of available SPRAM, capable of holding up to 8,192 AES ciphertext blocks (each 128 bits). In our design, writing and reading operations are performed sequentially using the same base_addr indexing scheme that was used to store each ciphertext, ensuring proper data reconstruction and alignment during retrieval.\n\n\nActuation Module\nThis module’s primary purpose is to send any desired message and/or data through the mechanical actuators. We used it to send the ciphertext and key to the other side. Given a specific FPGA clock frequency, CLK_FREQ, we can set our desired transfer frequency TX_FREQ which is implemented using a specific clock divider that ensures the ourput clock matches the desired frequency. THe module splices the 256 bits into 32 blocks, each carrrying 1 byte. The byte lines are activated on the rising edge of tx_clk and closed on the falling edge. This was designeed to ensure the FPGA on the other can properly sample the inputs and that we can debounce effectively.\n\n\nSender Module\nThis module combines all the modules above to ensure they are connected and communicate properly. It instantiates the FPGA main clock and is able to connect and communicate to everything effectively.\n\n\n\n\n\n\nFigure 1: Sender Module Block Diagram"
  },
  {
    "objectID": "pages/fpga.html#receiver-fpga-design",
    "href": "pages/fpga.html#receiver-fpga-design",
    "title": "FPGA Design",
    "section": "Receiver FPGA Design",
    "text": "Receiver FPGA Design\nThe receiver FPGA received the bytes from the actuators, concatenated them to reconstruct the cyphertext and the key, sent them directly to the decryption module which executed decryption and would send the results to the MCU via SPI.\n\nByte Receiving Module\nOn the rising edge of tx_clk, the module waits a short time and then samples the signal lines to read the inputs. It has a variable TOTAL_BYTES that defined the number of bytes it is expected to receive. once done, it would concatenate everything and output the the cyphertext and the key so they can be used by the decryption module. It had a custom SPI implementation that sent the received data to the MCU for debugging purposes. It was so that we can check and see if the interpreted data is exactly what we wanted.\n\n\nDecryption Module\nThis module receives the key and cyphertext from the byte receiving module, executes decryption, and sends the results to the MCU via a custom SPI interface. Information about decryption and this module implementation can be found in AES Decryption Overview webpage.\n\n\nReciever Module\nThis module combines all the modules above to ensure they are connected and communicate properly. It instantiates the FPGA main clock and is able to connect and communicate to everything effectively."
  },
  {
    "objectID": "pages/aesEncryption.html",
    "href": "pages/aesEncryption.html",
    "title": "Hardware-Accelerated AES Encryption",
    "section": "",
    "text": "AES is a symmetric encryption algorithm that uses a specific key to both encrypt and decrypt data. It is the global standard for secure data encryption and is defined in three key sizes: AES-128, AES-192, and AES-256, where the number indicates the bit length of the cipher key. A larger key size provides stronger security but requires more hardware resources. The MCU and FPGA combine to implement a hardware-accelerated version of the Advanced Encryption Standard (AES) for 128-bit data encryption. The MCU stores and provides the plaintext and cipher key, transmitted to the FPGA via the SPI interface. The FPGA performes the AES encryption according to the NIST-197 standard and then returns the resulting ciphertext to the MCU for verification. The description below ou"
  },
  {
    "objectID": "pages/aesEncryption.html#introduction",
    "href": "pages/aesEncryption.html#introduction",
    "title": "Hardware-Accelerated AES Encryption",
    "section": "",
    "text": "AES is a symmetric encryption algorithm that uses a specific key to both encrypt and decrypt data. It is the global standard for secure data encryption and is defined in three key sizes: AES-128, AES-192, and AES-256, where the number indicates the bit length of the cipher key. A larger key size provides stronger security but requires more hardware resources. The MCU and FPGA combine to implement a hardware-accelerated version of the Advanced Encryption Standard (AES) for 128-bit data encryption. The MCU stores and provides the plaintext and cipher key, transmitted to the FPGA via the SPI interface. The FPGA performes the AES encryption according to the NIST-197 standard and then returns the resulting ciphertext to the MCU for verification. The description below ou"
  },
  {
    "objectID": "pages/aesEncryption.html#encryption-overview",
    "href": "pages/aesEncryption.html#encryption-overview",
    "title": "Hardware-Accelerated AES Encryption",
    "section": "Encryption Overview",
    "text": "Encryption Overview\nAES encrypts data through a sequence of sub-algorithms and transformations that repeatedly mix the key with the plaintext to produce a ciphertext that appears random and cannot be reversed without the correct key. These transformations operate on matrices of bytes, with the key itself acting as one of the main transformation matrices. The encryption process consists of four main operations:\n\nSubBytes(): performs a non-linear byte substitution using a 16×16 S-box lookup table of random magic numbers.\nshiftRows(): cyclically shifts the rows of the state matrix to the left by varying offsets depending on row.\nmixColumns(): transforms each column of the state matrix using Galois Field arithmetic to further diffuse the data.\nAddRoundKey(): combines the current state with a round key using a bitwise XOR operation.\n\nFinally, these operations are repeated across multiple rounds of encryption, each using a different round key derived through an algorithm known as keyExpansion(). In the AES-128 implementation used in this application, the encryption involves 10 rounds. Each round follows the sequential: AddRoundKey → SubBytes → ShiftRows → MixColumns, with the final round (10) skipping the MixColumns step. This datapath aggregated over 10 rounds is what constitutes the full AES Encryption."
  },
  {
    "objectID": "pages/aesEncryption.html#experiment-setup-and-design-overview",
    "href": "pages/aesEncryption.html#experiment-setup-and-design-overview",
    "title": "Hardware-Accelerated AES Encryption",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\n\nMCU Setup\nThe MCU was configured to implement the SPI mode 1. It was also set up as the master with an artificial chip select signal to allow 8-bit CE-based SPI decoding on the logic analyzers. The MCU controlled the internal signals that started the SPI transactions. The MCU would set the signal load to the FPGA that prepares it to recieve inputs. The MCU then sends the cipherkey and then the plaintext and then would set load LOW to signal that all data is sent. During that period, the FPGA performs encryption and once all 10 rounds complete, the FPA sets the signal done HIGH so that the MCU prepares to receive the ciphertext.\nFor debugging: MCU had code that tested using standard NIST vectors. Once the cyphertext is received, it compared it to the expected cyphertext through a difference operation. If all operations yield zero, a green LED through PA9 would light up, otherwise a red LED at P10 lights up indicating that encryption didn’t work properly. This process was always triggered using the MCU reset that restarted the transactions.\n\n\nFPGA Setup and Encryption Pipeline\nSince all encryption was done by the FPGA, we had to write SystemVerilog modules to perform the transformation operations necessary for executing the AES encryption. A lot of these operations required heavy resource usage as operations such as key expansion are applied across a 128-bit word. This would always run the risk of exhausting LUTs and other FPGA resources. Therefore we had to take into account how the encryption logic is synthesized to ensure the implied hardware isn’t too heavy for the FPGA. The subBytes() lookup table was loaded into the FPGA embedded block RAMs (EBR) which have the ability to store files upto 128kB. To ensure it is mapped properly to the EBRs, we used a clocked version of the AES byte substitution algorithm named sbox_sync(). This module could only parse an 8-bit word so in subBytes(), it was called 16 times to parse the full 128-bit word. The shiftRows() module performed some row permutation by rotating the 4 rows: row 0 was kept as is, row 1 was shifted left by 1, row 2 by 2, and row 3 by 3. After row permutation, mixColumns() treats each state as a four-byte vector and performs matrix multiplication (Galois field operations) on the bytes in a column withinin \\(GF(2^8)\\) followed by XOR operations to handle overflows. Next up is the addRoundKey() that performs XOR operations between the 128-bit word and the 128-bit key. Finally, the module getNextKey() which performed the key expansion part of AES which receives a 128-bit key value and the tound constant, rcon, which is a series of 4-byte words used in the key schedule to create the sub-keys for each encryption round. The module would determine the key for the next round following the implementation and pseudocode provided in the standards document.\nUsing a synchronized sbox meant that it takes multiple cycles per round to process the data sequentially and safely propagate signals through the combinational logic. Therefore we used cycleCountto basically set when to take inputs, when to latch outputs and when to move to the next rounds. The cycle count was also to help account for the single cycle delay caused by subBytes(). Without it, the datapath would race and try to perform key operations before byte substitution stabilizes.\nAll the submodules described above were combined in a module named aes_core() whose job was implement the encryption datapath. The datapath followed the structure described in the AES Overview section above. The module took in the load signal that is asserted by the MCU after sending the plaintext and key, then initiated the process. The FPGA would continously reset/update internal signals as long as load was HIGH. For round 0, the plaintext is XORed with the key and the result is passed on to the next rounds. In rounds 1 to 9, the key is updated each round alongside the the input to the datapath. This input is represented in the code as state as it hold the intermediate states of the data in-between rounds. After round 10, the done signal is asserted to prepare the MCU to receive the cyphertext.\nTo run the setup, we implemented the aes() module that prompts both aes_core() and the aes_spi() module that executes SPI communication between both the MCU and the FPGA. Since data is received by the FPGA based on SCK from the FPGA, we added a synchronizer that ensures the load signal referenced by the FPGA for encryption, is latched on the rising edge of the FPGA internal clock (HSOSC/clk) instead of the SPI clock domain. This eliminated any potential synchronization issues where encryption would be randomly true/false depending on the data latched. The connection and signals between these modules is shown in Figure 1."
  },
  {
    "objectID": "pages/aesEncryption.html#design-implementation",
    "href": "pages/aesEncryption.html#design-implementation",
    "title": "Hardware-Accelerated AES Encryption",
    "section": "Design Implementation",
    "text": "Design Implementation\nThe modules to enforce the AES encryption and those that control the respective encryption transformation algorithms were written in SystemVerilog to run on the FPGA. To ensure proper communication and signal control between the MCU and FPGA, all signals followed the hierachy in the block diagram below:\n\n\n\n\n\n\nFigure 1: Hierachical Block Diagram\n\n\n\naes_core() involves multiple blocks and enabler logic that manages the flow of signals and data through the different transformations within the datapath as shown in Figure 2 below:\n\n\n\n\n\n\nFigure 2: aes_core() Hierachical Block Diagram\n\n\n\nTo ensure proper functionality and communication, the full setup is installed on the development board. The board used already had DIP switches that connect specific MCU pins to specific FPGA pins which reduces the need for crossing wires. Other necessary signals like the debugging LEDs are setup on a side breadboard. The complete setup is shown in the following schematic:\n\n\n\n\n\n\nFigure 3: AES encryption Wiring Setup"
  },
  {
    "objectID": "pages/actuator.html",
    "href": "pages/actuator.html",
    "title": "Mechanical Design of The Actuation System",
    "section": "",
    "text": "The actuation system was integral to the success of the project as it was the link responsibe for moving data from the sender side to the receiver side. It combines the necessary components which are: relay modules, solenoids, actuation shaft, as well as the limit swithces. To make sure these components work as desired, they had to be fixed in place. This was done by 3D printing different components/sections necessary to hold the 9 different channels together making it easier to carry around and neat. Information about the individual components can be found in Documentation.\nN.B: All 3D printed parts are configured to be a tight fit of the relevant component they will be holding except for the part holding the acutation shafts. The clearance is + 0.1in from whatever dimension you want to constrain. For example the head of the solenoids has \\(\\text{Diameter } = 0.15in\\) thus the 3D printed part will have \\(\\text{Diameter } = 0.16in\\)"
  },
  {
    "objectID": "pages/actuator.html#overview",
    "href": "pages/actuator.html#overview",
    "title": "Mechanical Design of The Actuation System",
    "section": "",
    "text": "The actuation system was integral to the success of the project as it was the link responsibe for moving data from the sender side to the receiver side. It combines the necessary components which are: relay modules, solenoids, actuation shaft, as well as the limit swithces. To make sure these components work as desired, they had to be fixed in place. This was done by 3D printing different components/sections necessary to hold the 9 different channels together making it easier to carry around and neat. Information about the individual components can be found in Documentation.\nN.B: All 3D printed parts are configured to be a tight fit of the relevant component they will be holding except for the part holding the acutation shafts. The clearance is + 0.1in from whatever dimension you want to constrain. For example the head of the solenoids has \\(\\text{Diameter } = 0.15in\\) thus the 3D printed part will have \\(\\text{Diameter } = 0.16in\\)"
  },
  {
    "objectID": "pages/actuator.html#component-design-and-fitting",
    "href": "pages/actuator.html#component-design-and-fitting",
    "title": "Mechanical Design of The Actuation System",
    "section": "Component Design and Fitting",
    "text": "Component Design and Fitting\n\nRelay Block and Modules\nThe relay block is one of the main components of the setup. It is meant to house the relay modules in place leaving square openings exposing the 6 screw terminals of the relay module for connectiing other components and terminals. The relay block is shown in Figure 1 below:\n\n\n\n\n\n\nFigure 1: Isometric View of The Relay Holding Block\n\n\n\nThe tiny circular holes shown at the top hold debugging LED that are used to vizualize if the respective signal line is activated. That is, if the FPGA sends a logic HIGH, the LED in that opening lights up. The other huge opening in the top left holds a toggle flip switch that turns ON or OFF the whole block. The wires are daisy chained to reduce the wiring mess. This is possible because all relays are powered by the same voltage, \\(12V\\), and require the same ground reference. The debugging LED are the hardest to setup. We soldered \\(100\\Omega\\) resistors to the anode legs and bent them to fit into the square openings seen in the block. The other leg of the resistor slots in the signal input terminal of the relay while the LED cathode leg is locked inside the the relay ground terminal. The fully assembled relay block is shown in Figure 2 below:\n\n\n\n\n\n\nFigure 2: Full Assembly of The Relay Holding Block\n\n\n\n\n\nSoleonid Holder\nThe solenoid block has a square opening to hold the solenoid module. Behind the square holes, there is circular holes that are used create a good clearance for the solenoid spring heads and for them to slide without scraping or locking. The relay block is shown in Figure 3 below:\n\n\n\n\n\n\nFigure 3: Isometric View of The Solenoid Holding Block\n\n\n\nThe extendedstands from the corners are drilled through to house screws that connect and lock the solenoid block to the relay block. The grounds of the individual solenoids are daisy chained as well and conected to the reference ground of the relays while the power ternimals connect to the Normally Closed (NC) exit terminals of the relay. The fully assembled solenoid block is shown in Figure 4 below:\n\n\n\n\n\n\nFigure 4: Full Assembly of The Solenoid Holding Block\n\n\n\n\n\nShaft Guide and Shafts\nThe shaft guides block was the most straightforward piece with rings that have a good enough opening to accomodate \\(0.25in\\) thick, \\(5in\\) long shafts. It also has the seame extensions that help lock it to the solenoid block with screws too. The fully assembly is shown in Figure 5 below:\n\n\n\n\n\n\nFigure 5: Full Assembly after Shafts and Shaft Guides\n\n\n\n\n\nLimit Switch Holder\nThe limit switch holder was another crucial part. The kick from the solenoids once energized is huge so the block had to be able to stay stable as well as lock the switches so they press insted of being moved back by the solenoids. The switch holder is shown in Figure 6 below:\n\n\n\n\n\n\nFigure 6: Isometric View of The Switch Holding Block\n\n\n\nThe limit switches also feature daisy chained ground wires extending out of the back of the block as well as signal lines that go to the MCU. The switches are tightly fit and can be moved back or forward to create the necessary distance ensuring better actuation. The fully assembly is shown in Figure 7 and Figure 8 below:\n\n\n\n\n\n\nFigure 7: Full Assembly of The Switch Holding Block (Front)\n\n\n\n\n\n\n\n\n\nFigure 8: Full Assembly of The Switch Holding Block (Back)\n\n\n\nAfter making all the blocks and fitting the necessary components in each section, the blocks are linked by drilling \\(\\frac{1}{8}\\text{in}\\) holes in the shown areas to fit the connecting screws. Connecting all individual components yields the following setup:\n\n\n\n\n\n\nFigure 9: Isometric Front View of Full Actuation Assembly\n\n\n\n\n\n\n\n\n\nFigure 10: Isometric Back View of Full Actuation Assembly"
  },
  {
    "objectID": "pages/aesDecryption.html",
    "href": "pages/aesDecryption.html",
    "title": "Hardware-Accelerated AES Decryption",
    "section": "",
    "text": "AES decryption is conceptually the mathematical inverse of AES encryption and therefore applies the opposite operations in reversed order. This is only correct to some extent, depending on the specific algorithm used. The implementation in this project uses the Equivalent Inverse Cipher algorithm to recover the plaintext. Similar to encryption, the MCU and FPGA are used where the MCU provides the key and ciphertext while the FPGA performs decryption and sends the plaintext to the MCU via SPI protocol."
  },
  {
    "objectID": "pages/aesDecryption.html#introduction",
    "href": "pages/aesDecryption.html#introduction",
    "title": "Hardware-Accelerated AES Decryption",
    "section": "",
    "text": "AES decryption is conceptually the mathematical inverse of AES encryption and therefore applies the opposite operations in reversed order. This is only correct to some extent, depending on the specific algorithm used. The implementation in this project uses the Equivalent Inverse Cipher algorithm to recover the plaintext. Similar to encryption, the MCU and FPGA are used where the MCU provides the key and ciphertext while the FPGA performs decryption and sends the plaintext to the MCU via SPI protocol."
  },
  {
    "objectID": "pages/aesDecryption.html#decryption-overview",
    "href": "pages/aesDecryption.html#decryption-overview",
    "title": "Hardware-Accelerated AES Decryption",
    "section": "Decryption Overview",
    "text": "Decryption Overview\nJust like encryption performs SubBytes(), ShiftRows(), MixColumns(), and AddRoundKey() in that order, decryption uses InvShiftRows(), InvSubBytes(), InvMixColumns(), and AddRoundKey() to retrieve the original plaintext. However, decryption requires AddRoundKey() to occur at the beginning of each round rather than at the end, which breaks symmetry with the encryption pipeline and complicates reuse of hardware. To avoid this, we used Equivalent Inverse Cipher (EIC) which rearranges the the inverse transformations so that the round structure follows the same order and pipeline as encryption which is feasible for hardware resuse and less complicated implementation. Now, all decryption rounds except the final one to follow the same 4-cycle micro-pipeline. However, for this to work, decryption requires additional processing of the key schedule: all keys for round 1 through 9 must be generated early and then premixed using InvMixColumns() before being used in the datapath while keeping round 0 and 10 constant. This means that all the round keys have to be pre-generated before decryption starts. Despite all of this, EIC is still relatively faster and efficient than the traditional Inverse Cipher."
  },
  {
    "objectID": "pages/aesDecryption.html#fpga-setup-and-decryption-pipeline",
    "href": "pages/aesDecryption.html#fpga-setup-and-decryption-pipeline",
    "title": "Hardware-Accelerated AES Decryption",
    "section": "FPGA Setup and Decryption Pipeline",
    "text": "FPGA Setup and Decryption Pipeline\nDecryption on the FPGA is divided into two major phases: Key Expansion and Decryption outlined below.\n\nKey Schedule and Premixing\nThe key schedule uses the same algorithm as encryption, which is advantageous because the AES specification requires that key expansion must use the forward S-box even when decrypting. In this case, the module getNextKeyEIC() behaves like getNextKey() from encryption but uses the combinational S-box, sbox() because we wanted the nextkey to be valid and stored within the same clock cycle. Each generated key was then stored as a raw key in the array roundKeys[]. The freshly generated 128-bit key is passed into inv_mixcolumns(), producing the premixed result which is then stored in the array premixedKeys[] for rounds 1 through 9. This process is gated by specific signals: while ka_busy is active, all key generation and premixing operations proceed, and only after ka_done is asserted does the actual decryption begin.\n\n\nDecryption Execution\nWhen the load is asserted by the MCU, the system loads the 128-bit input key into currKey and roundKeys[0], while the ciphertext is captured into bfrAdd. The system now begins the key expansion. After ka_done is asserted, decryption begins with roundCount initialized to 10. The first operation applies AddRoundKey() using the raw round 10 key. Once this initial step is complete, the pipeline executes rounds 9 through 1 using the EIC transformations. In cycle 0, the appropriate premixed round key (premixedKeys[roundCount]) is loaded into word, and the current state is pushed into bfrSub. In cycle 1, the inverse SubBytes output, afterSub, becomes valid, and ShiftRows is applied, producing afterShift. In cycle 2, the inverse MixColumns output, afterMix is XORed with the round key through addRoundKey, and the result is fed into bfrAdd. In cycle 3, the newly computed afterAdd value is committed to state, completing the round and preparing the system for the next decrement of roundCount. This pipelined sequence continues identically until round 1 finishes.\nThe final round (round 0) omits the inverse MixColumns step. Instead, the raw key for round 0 is loaded into word, and after inverse SubBytes and inverse ShiftRows, the output of afterShift is XORed directly with round 0 key to produce the final plaintext. When this result is written to the plaintext register, the module asserts done_decrypt, signaling completion to the MCU.\nSimilar to encrtyption, the pipeline above is wrapped under aes_core() which is called by the aes() top module that also calls aes_spi() meant to execute SPI communication between both the MCU and the FPGA. load is also synchronized to the FPGA clock to eliminate any potential synchronization issues. The connection and signals between these modules is shown in Figure 1."
  },
  {
    "objectID": "pages/aesDecryption.html#design-implementation",
    "href": "pages/aesDecryption.html#design-implementation",
    "title": "Hardware-Accelerated AES Decryption",
    "section": "Design Implementation",
    "text": "Design Implementation\nThe modules to enforce the AES decryption and those that control the respective decryption transformation algorithms were written in SystemVerilog to run on the FPGA. To ensure proper communication and signal control between the MCU and FPGA, all signals followed the hierachy in the block diagram below:\n\n\n\n\n\n\nFigure 1: Hierachical Block Diagram\n\n\n\naes_core() involves multiple blocks and enabler logic that manages the flow of signals and data through the different transformations within the datapath as shown in Figure 2 below:\n\n\n\n\n\n\nFigure 2: aes_core() Hierachical Block Diagram\n\n\n\nTo ensure proper functionality and communication, the full setup is installed on the development board. The board used already had DIP switches that connect specific MCU pins to specific FPGA pins which reduces the need for crossing wires. Other necessary signals like the debugging LEDs are setup on a side breadboard. The complete setup is shown in the following schematic:\n\n\n\n\n\n\nFigure 3: AES encryption Wiring Setup"
  },
  {
    "objectID": "pages/documentation.html",
    "href": "pages/documentation.html",
    "title": "Documentation",
    "section": "",
    "text": "Below are pictures of the electrical schematics for our mechanical actuation system\n\n\n\n\n\n\nFigure 1: Schemactic of the Sender Actuation Side\n\n\n\n\n\n\n\n\n\nFigure 2: Schemactic of the Receiver Actuation Side\n\n\n\nThe assembly of the LCD required a level shifter to boost voltages into the required range as shown below:\n\n\n\n\n\n\nFigure 3: Level Shifter and ESP8266 Schematic"
  },
  {
    "objectID": "pages/documentation.html#electrical-schematics",
    "href": "pages/documentation.html#electrical-schematics",
    "title": "Documentation",
    "section": "",
    "text": "Below are pictures of the electrical schematics for our mechanical actuation system\n\n\n\n\n\n\nFigure 1: Schemactic of the Sender Actuation Side\n\n\n\n\n\n\n\n\n\nFigure 2: Schemactic of the Receiver Actuation Side\n\n\n\nThe assembly of the LCD required a level shifter to boost voltages into the required range as shown below:\n\n\n\n\n\n\nFigure 3: Level Shifter and ESP8266 Schematic"
  },
  {
    "objectID": "pages/documentation.html#bill-of-materials",
    "href": "pages/documentation.html#bill-of-materials",
    "title": "Documentation",
    "section": "Bill of Materials",
    "text": "Bill of Materials\n\nBOM for Final Project\n\n\nPart Name\nPart Number\nQuantity\nVendor\nPrice\nLink\n\n\n\n\n12V Relay Module\nSRD-12VDC-SL-C\n10\nAEDIKO\n13.20\nLink\n\n\n12V Solenoid\nZ24G50031OJX\n9\nTEHAUX\n28.26\nLink\n\n\nRoller Lever Arm Micro Limit Switch\nKW12-3\n10\nHiLetgo\n6.60\nLink\n\n\nLCD Display with I2C Adapter\nLCD2004\n10\nSunFounder\n14.26\nLink\n\n\nFPGA\nUpduino v3.1\n2\nUpduino\nStockroom\nN/A\n\n\nMCU\nSTM32L432KC\n2\nSTM\nStockroom\nN/A\n\n\n3D Printed Rods\nN/A\n9\nN/A\nMakerspace\nN/A\n\n\nESP8266\nESP-WROOM-02\n2\nEdwin Robotics\nStockroom\nN/A\n\n\n3D Printer & PLA\nN/A\nN/A\nN/A\nMakerspace\nN/A\n\n\n20 V 12 A Power Supply\n72-6153\n1\nTENMA\nStockroom\nN/A\n\n\n20 V 0.5 A Power Supply\nE3630A\n1\nHP\nDigital Lab\nN/A\n\n\nTotal\n\n\n\n$62.32\n\n\n\n\nWhile we were working on our project, we did not realize how much current our 9 solenoids drew, especially when all of them were on. It was drawing around 0.85 A for each solenoid. The power supply at the digital lab only supplies a maximum of 0.5 A on the 20 V setting, which means we would always overload the power supply. Thus, we were able to use a big power supply that was in the stockroom, which supported up to 12 Amps. Below is a picture of the power supply:\n\n\n\n20 V 12 Amp Power supply used for Solenoids"
  },
  {
    "objectID": "pages/documentation.html#acknowledgements",
    "href": "pages/documentation.html#acknowledgements",
    "title": "Documentation",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nWe would like to thank Prof Spencer for his detailed feedback and support throughout the project, guiding us in the right direction to solve problems. We would also like to thank Xavier for helping us with the ideation process for the project and ironing out any issues and confusions that we had. We would also like to thank Jacob for his kindness and support, and willingness to help us find all the parts we needed for this project."
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "MechaCrypt: Hardware-Encrypted Messaging System",
    "section": "",
    "text": "Ever wondered how data actually moves across bus lines and tiny copper traces inside our electronics? MechaCrypt was built to make that invisible process physical. It demonstrates how the messages we send through apps are interpreted by a machine, processed, secured, and finally delivered to someone on the other side. Instead of using traditional electrical signaling through wire buses, MechaCrypt transmits information through a serial mechanical-actuation system, letting you see the data transfer process as it happens.\nThe system accepts a user message on the Sender side, encrypts it, and mechanically transmits the resulting ciphertext to the Receiver side, where it is decrypted only after arrival, mimicing the guarantees of end-to-end encryption. To enhance data security, MechaCrypt uses the MCU’s True Random Number Generator (TRNG) to generate a fresh cipher key for every block of data, mirroring real-world secure messaging protocols. All encryption and decryption operations are implemented directly on the FPGAs to ensure fast, hardware-accelerated processing.\nBoth MCUs parse and interpret the message using ASCII, the fundamental character-encoding standard in computing. The entire user experience is wrapped in custom web applications that allow two users to interact with the Sender and Receiver. Due to hardware constraints, MechaCrypt currently operates in simplex mode (one-way communication), but it fully showcases the flow of secure data transmission. An onboard LCD screen provides real-time feedback, showing the progress of each message as it moves through the system."
  },
  {
    "objectID": "pages/index.html#abstract",
    "href": "pages/index.html#abstract",
    "title": "MechaCrypt: Hardware-Encrypted Messaging System",
    "section": "",
    "text": "Ever wondered how data actually moves across bus lines and tiny copper traces inside our electronics? MechaCrypt was built to make that invisible process physical. It demonstrates how the messages we send through apps are interpreted by a machine, processed, secured, and finally delivered to someone on the other side. Instead of using traditional electrical signaling through wire buses, MechaCrypt transmits information through a serial mechanical-actuation system, letting you see the data transfer process as it happens.\nThe system accepts a user message on the Sender side, encrypts it, and mechanically transmits the resulting ciphertext to the Receiver side, where it is decrypted only after arrival, mimicing the guarantees of end-to-end encryption. To enhance data security, MechaCrypt uses the MCU’s True Random Number Generator (TRNG) to generate a fresh cipher key for every block of data, mirroring real-world secure messaging protocols. All encryption and decryption operations are implemented directly on the FPGAs to ensure fast, hardware-accelerated processing.\nBoth MCUs parse and interpret the message using ASCII, the fundamental character-encoding standard in computing. The entire user experience is wrapped in custom web applications that allow two users to interact with the Sender and Receiver. Due to hardware constraints, MechaCrypt currently operates in simplex mode (one-way communication), but it fully showcases the flow of secure data transmission. An onboard LCD screen provides real-time feedback, showing the progress of each message as it moves through the system."
  },
  {
    "objectID": "pages/index.html#new-hardware",
    "href": "pages/index.html#new-hardware",
    "title": "MechaCrypt: Hardware-Encrypted Messaging System",
    "section": "New Hardware",
    "text": "New Hardware\nThe new hardware that we will be implementing onto this project is the use of an LCD display. A traditional LED display requires 8 GPIO pins, which would use up a lot of the pins on our MCU, so we are using an I2C adapter for our 8 GPIO pins. In order to power our display, we will need to learn how to use and implement I2C on our STM32 Microcontroller to be able to display an text that we want onto the display.\n\n\n\n\n\n\nFigure 1: 20x04 LCD Display with I2C Adapter"
  },
  {
    "objectID": "pages/index.html#system-overview",
    "href": "pages/index.html#system-overview",
    "title": "MechaCrypt: Hardware-Encrypted Messaging System",
    "section": "System Overview",
    "text": "System Overview\nThe applications on both sides of MechaCrypt are nearly identical, so most of the hardware is duplicated. Each side’s MCU acts as the primary controller: it manages the message flow, drives the inputs to its local FPGA, and handles all required communication protocols (USART, SPI, and I2C). The MCUs also process web requests through the ESP8266 modules, enabling seamless interaction with the custom web applications. Both MCUs collaborate to control the LCD display. The Sender MCU knows the total length of the outgoing message, while the Receiver MCU tracks how many characters have arrived. By exchanging this information, they coordinate the real-time progress updates shown on the LCD.\nAll the relevant elements defined in the description above are connected together following the communication protocols and setup in Figure 2 below:\n\n\n\n\n\n\nFigure 2: High Level Block Diagram\n\n\n\nBelow is also a flowchart of how messages go from the user to receiver through our project in Figure 3:\n\n\n\n\n\n\nFigure 3: High Level Data Flow Diagram"
  },
  {
    "objectID": "pages/index.html#table-of-contents",
    "href": "pages/index.html#table-of-contents",
    "title": "MechaCrypt: Hardware-Encrypted Messaging System",
    "section": "Table of Contents",
    "text": "Table of Contents\nFor more information about the setup an implementation, check out the other resources and pages below:\n\nAES Overview: Provides insight into AES as well as information on how to setup hardware-accelerated encryption and decryption on the UPduino 3.1 FPGA\n\nAES Encryption: Procedural demonstration on how to setup and configure, setup, and validate the AES-128 bit encryption pipeline.\nAES Decryption: Procedural demonstration on how to setup and configure, setup, and validate the AES-128 bit decryption pipeline.\n\nFPGA Design: SPRAM configuration and usage, mechanical bit-level signaling, cross-side communication, and full AES encryption/decryption implementation.\nMCU Design: USART, SPI, and I2C protocols, LCD control, TRNG, reading bits from the actuation, and ESP8266 Web requests and web server setup\nMechanical Design: A detailed walkthrough of the design and assembly of the mechanical actuation system.\nDocumentation: General circuit schematics, BOM, references, and acknowledgements.\nResults: A presentation of the project’s outcomes, including test results, performance benchmarks, and an example communication.\nTeam: Self introductions about the team behind the project."
  },
  {
    "objectID": "pages/results.html",
    "href": "pages/results.html",
    "title": "Results",
    "section": "",
    "text": "The goal of this project was to allow the user to send any message, have it encrypted and sent over a mechanical system, get decrypted, and then displayed on a receiver end website."
  },
  {
    "objectID": "pages/results.html#overview",
    "href": "pages/results.html#overview",
    "title": "Results",
    "section": "",
    "text": "The goal of this project was to allow the user to send any message, have it encrypted and sent over a mechanical system, get decrypted, and then displayed on a receiver end website."
  },
  {
    "objectID": "pages/results.html#software-results",
    "href": "pages/results.html#software-results",
    "title": "Results",
    "section": "Software Results",
    "text": "Software Results\nOur project sender side executes properly as desired. We are able to trigger all operations and send over the cyphertext and the key through the mechanical module properly. The receiver side was a shortcoming because we couldn’t properly sample the inputs from the receiver side that matches what was sent through by the sender side. However, we are confident that our modules perform the desired operations properly as shown in the testebench demonstrations below. We configured the testbench to have a lot of monitor signal so we can track bit by bit everything that is sent.\n\n\n\n\n\n\nFigure 1: Message Byte Receiver Module Testbench\n\n\n\nFromt the resuslts and the monitor signals above, we can see that the expected bytes are received and reconstructed at the end which is what we expect to happen.\n\n\n\n\n\n\nFigure 2: Debugging SPI\n\n\n\nThe debugging SPI also shows that we can properly shift out the bits to the MCU for use to check data."
  },
  {
    "objectID": "pages/results.html#hardware-results",
    "href": "pages/results.html#hardware-results",
    "title": "Results",
    "section": "Hardware Results",
    "text": "Hardware Results\nWe were able to successfully actuate our mechanical system from our FPGA, with a user determined input message. During our process of getting the mechanical system to work, we realized that each solenoid was drawing close to 0.85 A of current, which overloads our lab bench power supply. Thus, we were able to find a bigger 12 Amp power supply to support our 6 A of current needed by all the solenoids being on at once.\nWe were able to use our FPGA to set the sending speed of our mechanical system. Per our specs, we chose to send it at 3 Hz, or the equivalent of 3 bytes per second without any issues.\nBelow is a demo video of us inputting a message on the website, and the ciphertext and key sent over the mechanical system."
  }
]