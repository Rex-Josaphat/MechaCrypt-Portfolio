[
  {
    "objectID": "pages/fpga.html#fpga-systems",
    "href": "pages/fpga.html#fpga-systems",
    "title": "FPGA Design",
    "section": "FPGA Systems",
    "text": "FPGA Systems\n\nBridge Module\nThe bridge module is responsible for transferring the encryption key generated by MCU 1 (via the TRNG) and the total message length expected from the sender. The key is required by FPGA 2 to decrypt the incoming message, while the length is used for data checking and tracking transfer progress, which will be shown to the user. To support this, FPGA 2 communicates with both MCUs through a custom SPI interface where the FPGA shifts in 128 bits of key and 8 bits of message length from MCU 1 (MSB-first), and later shifts out the same 136-bit block to MCU 2. The protocol follows SPI Mode 0 timing, where data is sampled on the positive edge of SCK during reception and driven on the negative edge during transmission.\nThe design uses two independent SPI masters, MCU 1 for writing and MCU 2 for reading ensuring clean transfer boundaries. Each MCU controls its own SCK and CS lines, allowing them to initiate transfers without interfering or risking accidental shifts and stale data. The signal flow is as follows:\n\nAfter message parsing is done and the key is available, MCU 1 calculates the message length and pulls cs_in LOW to trigger a write transaction on FPGA 2.\nThe FPGA 2 shifts in all 136 bits, then asserts ready, indicating that all data is available.\nMCU 2 receives the signal as a GPIO interrupt and pulls cs_out LOW to begin its read transaction.\nOnce MCU 2 is done, it pulls cs_out HIGH. The FPGA detects this rising edge and automatically resets all internal registers back to idle (0)."
  },
  {
    "objectID": "pages/aesEncryption.html",
    "href": "pages/aesEncryption.html",
    "title": "AES Encryption",
    "section": "",
    "text": "In this lab, the MCU and FPGA were used together to implement a hardware-accelerated version of the Advanced Encryption Standard (AES) for 128-bit data encryption. The MCU stored the plaintext, cipher key, and expected ciphertext, and transmitted the plaintext and key to the FPGA via the SPI interface. The FPGA performed the AES encryption according to the NIST-197 standard and then returned the resulting ciphertext to the MCU. Finally, the MCU compared the received ciphertext to the expected value and indicated the success or failure of the encryption process through output signals lighting either a green (success) or red (failure) LED."
  },
  {
    "objectID": "pages/aesEncryption.html#introduction",
    "href": "pages/aesEncryption.html#introduction",
    "title": "AES Encryption",
    "section": "",
    "text": "In this lab, the MCU and FPGA were used together to implement a hardware-accelerated version of the Advanced Encryption Standard (AES) for 128-bit data encryption. The MCU stored the plaintext, cipher key, and expected ciphertext, and transmitted the plaintext and key to the FPGA via the SPI interface. The FPGA performed the AES encryption according to the NIST-197 standard and then returned the resulting ciphertext to the MCU. Finally, the MCU compared the received ciphertext to the expected value and indicated the success or failure of the encryption process through output signals lighting either a green (success) or red (failure) LED."
  },
  {
    "objectID": "pages/aesEncryption.html#aes-overview",
    "href": "pages/aesEncryption.html#aes-overview",
    "title": "AES Encryption",
    "section": "AES Overview",
    "text": "AES Overview\nAES is a symmetric encryption algorithm that uses a specific key to both encrypt and decrypt data. It is the global standard for secure data encryption and is defined in three key sizes: AES-128, AES-192, and AES-256, where the number indicates the bit length of the cipher key. A larger key size provides stronger security but requires more hardware resources. AES encrypts data through a sequence of sub-algorithms and transformations that repeatedly mix the key with the plaintext to produce a ciphertext that appears random and cannot be reversed without the correct key. These transformations operate on matrices of bytes, with the key itself acting as one of the main transformation matrices. The encryption process consists of four main operations:\n\nSubBytes(): performs a non-linear byte substitution using a 16×16 S-box lookup table.\nshiftRows(): cyclically shifts the rows of the state matrix by varying offsets depending on row.\nmixColumns(): transforms each column of the state matrix using Galois Field arithmetic to further diffuse the data.\nAddRoundKey(): combines the current state with a round key using a bitwise XOR operation.\n\nFinally, these operations are repeated across multiple rounds of encryption, each using a different round key derived through an algorithm known as keyExpansion(). In the AES-128 implementation used in this lab, the encryption involves 10 rounds. Each round follows the sequence: AddRoundKey → SubBytes → ShiftRows → MixColumns, with the final round (10) skipping the MixColumns step."
  },
  {
    "objectID": "pages/aesEncryption.html#experiment-setup-and-design-overview",
    "href": "pages/aesEncryption.html#experiment-setup-and-design-overview",
    "title": "AES Encryption",
    "section": "Experiment Setup and Design Overview",
    "text": "Experiment Setup and Design Overview\n\nMCU Setup\nThe MCU was already configured through the provided starter code. It was configured to implement the SPI mode 1. It was also set up as the master with an artificial chip select signal to allow 8-bit CE-based SPI decoding on the logic analyzers. The MCU controlled the internal signals that started the SPI transactions as well as checked results from the transactions. The MCU would set the signal load to the FPGA that prepares it to recieve inputs. The MCU then sends the plaintext and then the cipherkey and then would set load LOW to signal that all data is sent. During that period, the FPGA performs encryption and once all 10 rounds complete, the FPA sets the signal done HIGH so that the MCU prepares to receive the ciphertext. Once received, the MCU compared it to the expected cipher through a difference operation. If all operations yield zero, the green LED through PA9 would light up, otherwise the red LED at P10 lights up indicating that encryption didn’t work properly. This process was always triggered using the MCU reset that restarted the transactions.\n\n\nFPGA Setup\nSince all encryption was done by the FPGA, we had to write SystemVerilog modules to perform the transformation operations necessary for executing the AES encryption. A lot of these operations required heavy resource usage as operations such as key expansion are applied across a 128-bit word. This would always run the risk of exhausting LUTs and other FPGA resources. Therefore I had to take into account how my logic synthesized to ensure the implied hardware isn’t too heavy for the FPGA. The subBytes() lookup table was loaded into the FPGA embedded block RAMs which have the ability to store files upto 128kB. To ensure it is mapped properly to the EBRs, we used a clocked version of the AES byte substitution algorithm named sbox_sync(). This module could only parse an 8-bit word so in subBytes(), it was called 16 times to parse the full 128-bit word. The shiftRows() module performed some row permutation by rotating the 4 rows: row 0 was kept as is, row 1 was shifted left by 1, row 2 by 2, and row 3 by 3. After row permutation, mixColumns() treats each state as a four-byte vector and performs matrix multiplication (Galois field operations) on the bytes in a column withinin \\(GF(2^8)\\) followed by XOR operations to handle overflows. Next up is the addRoundKey() that performs XOR operations between the 128-bit word and the 128-bit key. Finally, I wrote down the module getNextKey() which performed the key expansion part of AES which receives a 128-bit key value and the tound constant, rcon, which is a series of 4-byte words used in the key schedule to create the sub-keys for each encryption round. The module would determine the key for the next round following the implementation and pseudocode provided in the standards document.\nAll the submodules described above were combined in a module named aes_core() whose job was implement the encryption datapath. The datapath followed the structure described in the AES Overview section above. The module took in the load signal that is asserted by the MCU after sending the plaintext and key, then initiated the process. The FPGa would continously reset/update internal signals as long as load was HIGH. For round 0, the plaintext is XORed with the key and the result is passed on to the next rounds. In rounds 1 to 9, the key is updated each round alongside the the input to the datapath. This input is represented in the code as state as it hold the intermediate states of the data in-between rounds. After round 10, the done signal is asserted to prepare the MCU to receive the cyphertext.\nUsing a synchronized sbox meant that it takes multiple cycles per round to process the data sequentially and safely propagate signals through the combinational logic. Therefore I used cycleCountto basically set when to take inputs, when to latch outputs and when to move to the next rounds. The cycle count was also to help account for the single cycle delay caused by subBytes(). Without it, the datapath would race and try to perform key operations before byte substitution stabilizes.\nTo run the setup, we implemented the aes() module that prompts both aes_core() and the aes_spi() module that executes SPI communication betweent both the MCU and the FPGA. Since data is received by the FPGA based on SCK from the FPGA, I added a synchronizer that ensures the load signal referenced by the FPGA for encryption, is latched on the rising edge of the internal clock (HSOSC/clk) instead of the SPI clock domain. This eliminated a synchronization error where encryption would be randomly true/false depending on the data latched. The connection and signals between these modules is shown in Figure 1."
  },
  {
    "objectID": "pages/aesEncryption.html#design-implementation",
    "href": "pages/aesEncryption.html#design-implementation",
    "title": "AES Encryption",
    "section": "Design Implementation",
    "text": "Design Implementation\nThe modules to enforce the AES encryption and those that control the respective encryption transformation algorithms were written in SystemVerilog to run on the FPGA. To ensure proper communication and signal control between the MCU and FPGA, all signals followed the hierachy in the block diagram below:\n\n\n\n\n\n\nFigure 1: Hierachical Block Diagram\n\n\n\naes_core() involves multiple blocks and enabler logic that manages the flow of signals and data through the different transformations within the datapath as shown in Figure 2 below:\n\n\n\n\n\n\nFigure 2: aes_core() Hierachical Block Diagram\n\n\n\nAfter running the simulation ensuring modules work as expected, the full setup was installed on the development board. The board has DIP switches that connect specific MCU pins to specific FPGA pins which reduces the need for crossing wires. Other necessary signals like the LEDs were setup on a side breadboard. The complete setup is shown in the following schematic:\n\n\n\n\n\n\nFigure 3: AES encryption Wiring Setup"
  },
  {
    "objectID": "pages/aesEncryption.html#hardware-testing",
    "href": "pages/aesEncryption.html#hardware-testing",
    "title": "AES Encryption",
    "section": "Hardware Testing",
    "text": "Hardware Testing\nThe testbenches were extremely helpful, especially for this particular lab. I was able to track how my key and other signals move around as I’m performing the key expansion. It allowed me to see how each data signal is loaded as well as when it is updated and it was how I realized the subBytes() issue. They were also essential in testing the modules that I had to write for this lab to ensure that the AES transformation modules function as expected. Each testbench was ran using examples from the NIST:197 Examples as well as other random hex values to check with more tests as possible.\n\n\n\n\n\n\nFigure 4: Example SPI Transaction on Logic Analyzer"
  },
  {
    "objectID": "pages/actuator.html",
    "href": "pages/actuator.html",
    "title": "Mechanical Design of The Actuation System",
    "section": "",
    "text": "The actuation system was integral to the success of the project as it was the link responsibe for moving data from the sender side to the receiver side. It combines the necessary components which are: relay modules, solenoids, actuation shaft, as well as the limit swithces. To make sure these components work as desired, they had to be fixed in place. This was done by 3D printing different components/sections necessary to hold the 9 different channels together making it easier to carry around and neat. Information about the individual components can be found in Documentation.\nN.B: All 3D printed parts are configured to be a tight fit of the relevant component they will be holding except for the part holding the acutation shafts. The clearance is + 0.1in from whatever dimension you want to constrain. For example the head of the solenoids has \\(\\text{Diameter } = 0.15in\\) thus the 3D printed part will have \\(\\text{Diameter } = 0.16in\\)"
  },
  {
    "objectID": "pages/actuator.html#overview",
    "href": "pages/actuator.html#overview",
    "title": "Mechanical Design of The Actuation System",
    "section": "",
    "text": "The actuation system was integral to the success of the project as it was the link responsibe for moving data from the sender side to the receiver side. It combines the necessary components which are: relay modules, solenoids, actuation shaft, as well as the limit swithces. To make sure these components work as desired, they had to be fixed in place. This was done by 3D printing different components/sections necessary to hold the 9 different channels together making it easier to carry around and neat. Information about the individual components can be found in Documentation.\nN.B: All 3D printed parts are configured to be a tight fit of the relevant component they will be holding except for the part holding the acutation shafts. The clearance is + 0.1in from whatever dimension you want to constrain. For example the head of the solenoids has \\(\\text{Diameter } = 0.15in\\) thus the 3D printed part will have \\(\\text{Diameter } = 0.16in\\)"
  },
  {
    "objectID": "pages/actuator.html#component-design-and-fitting",
    "href": "pages/actuator.html#component-design-and-fitting",
    "title": "Mechanical Design of The Actuation System",
    "section": "Component Design and Fitting",
    "text": "Component Design and Fitting\n\nRelay Block and Modules\nThe relay block is one of the main components of the setup. It is meant to house the relay modules in place leaving square openings exposing the 6 screw terminals of the relay module for connectiing other components and terminals. The relay block is shown in Figure 1 below:\n\n\n\n\n\n\nFigure 1: Isometric View of The Relay Holding Block\n\n\n\nThe tiny circular holes shown at the top hold debugging LED that are used to vizualize if the respective signal line is activated. That is, if the FPGA sends a logic HIGH, the LED in that opening lights up. The other huge opening in the top left holds a toggle flip switch that turns ON or OFF the whole block. The wires are daisy chained to reduce the wiring mess. This is possible because all relays are powered by the same voltage, \\(12V\\), and require the same ground reference. The debugging LED are the hardest to setup. We soldered \\(100\\Omega\\) resistors to the anode legs and bent them to fit into the square openings seen in the block. The other leg of the resistor slots in the signal input terminal of the relay while the LED cathode leg is locked inside the the relay ground terminal. The fully assembled relay block is shown in Figure 2 below:\n\n\n\n\n\n\nFigure 2: Full Assembly of The Relay Holding Block\n\n\n\n\n\nSoleonid Holder\nThe solenoid block has a square opening to hold the solenoid module. Behind the square holes, there is circular holes that are used create a good clearance for the solenoid spring heads and for them to slide without scraping or locking. The relay block is shown in Figure 3 below:\n\n\n\n\n\n\nFigure 3: Isometric View of The Solenoid Holding Block\n\n\n\nThe extendedstands from the corners are drilled through to house screws that connect and lock the solenoid block to the relay block. The grounds of the individual solenoids are daisy chained as well and conected to the reference ground of the relays while the power ternimals connect to the Normally Closed (NC) exit terminals of the relay. The fully assembled solenoid block is shown in Figure 4 below:\n\n\n\n\n\n\nFigure 4: Full Assembly of The Solenoid Holding Block\n\n\n\n\n\nShaft Guide and Shafts\nThe shaft guides block was the most straightforward piece with rings that have a good enough opening to accomodate \\(0.25in\\) thick, \\(5in\\) long shafts. It also has the seame extensions that help lock it to the solenoid block with screws too. The fully assembly is shown in Figure 5 below:\n\n\n\n\n\n\nFigure 5: Full Assembly after Shafts and Shaft Guides\n\n\n\n\n\nLimit Switch Holder\nThe limit switch holder was another crucial part. The kick from the solenoids once energized is huge so the block had to be able to stay stable as well as lock the switches so they press insted of being moved back by the solenoids. The switch holder is shown in Figure 6 below:\n\n\n\n\n\n\nFigure 6: Isometric View of The Switch Holding Block\n\n\n\nThe limit switches also feature daisy chained ground wires extending out of the back of the block as well as signal lines that go to the MCU. The switches are tightly fit and can be moved back or forward to create the necessary distance ensuring better actuation. The fully assembly is shown in Figure 7 below:\n\n\n\n\n\n\nFigure 7: Full Assembly of The Relay Holding Block\n\n\n\nAfter making all the blocks and fitting the necessary components in each section, the blocks are linked by drilling \\(\\frac{1}{8}\\text{in}\\) holes in the shown areas to fit the connecting screws. Connecting the full setup yields the following full setup:\n\n\n\n\n\n\nFigure 8: Top View of Full Actuation Assembly\n\n\n\n\n\n\n\n\n\nFigure 9: Isometric Front View of Full Actuation Assembly\n\n\n\n\n\n\n\n\n\nFigure 10: Isometric Back View of Full Actuation Assembly"
  },
  {
    "objectID": "pages/index.html",
    "href": "pages/index.html",
    "title": "MechaCrypt: Hardware-Encrypted Messaging System",
    "section": "",
    "text": "Project Overview"
  }
]