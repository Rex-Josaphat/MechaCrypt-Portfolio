<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.22">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MCU Design – MechaCrypt</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="..//assets/images/logo_mechacrypt.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-cd7454b418030687c631a6a7286fbe16.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-1cef86a8441353d14238f0f859bc59ef.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles/style.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">MechaCrypt</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../pages/index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-aes-overview" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">AES Overview</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-aes-overview">    
        <li>
    <a class="dropdown-item" href="../pages/aesEncryption.html">
 <span class="dropdown-text">AES Encryption</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../pages/aesDecryption.html">
 <span class="dropdown-text">AES Decryption</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../pages/fpga.html"> 
<span class="menu-text">FPGA Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../pages/mcu.html" aria-current="page"> 
<span class="menu-text">MCU Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../pages/actuator.html"> 
<span class="menu-text">Mechanical Design</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../pages/documentation.html"> 
<span class="menu-text">Documentation</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../pages/results.html"> 
<span class="menu-text">Results</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../pages/team.html"> 
<span class="menu-text">The Team</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/chrwu17/MechaCrypt.git"> <i class="bi bi-github" role="img" aria-label="GitHub Repository">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#sender-mcu-design" id="toc-sender-mcu-design" class="nav-link" data-scroll-target="#sender-mcu-design">Sender MCU Design</a></li>
  <li><a href="#receiver-mcu-design" id="toc-receiver-mcu-design" class="nav-link" data-scroll-target="#receiver-mcu-design">Receiver MCU Design</a></li>
  </ul>
<div class="quarto-code-links"><h2>Code Links</h2><ul><li><a href="https://github.com/chrwu17/MechaCrypt.git"><i class="bi bi-github"></i>Code Repository</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">MCU Design</h1>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This project consists of two MCUs, one for the sender end, and one for the receiver end. For each MCU, we will describe each peripheral that we integrate it, how communication is established with the MCU, and what data is sent.</p>
</section>
<section id="sender-mcu-design" class="level2">
<h2 class="anchored" data-anchor-id="sender-mcu-design">Sender MCU Design</h2>
<p>For the sender MCU, it will utilize TRNG to generate random keys, it will connect to the sender FPGA where encryption occurs, it will be connected to a ESP8266 where user inputs occur, and it will be connected to the receiver FPGA to send over the randomly generated keys and the total number of 128-bit blocks of the message that is being sent by the user. Below, we will describe in detail how this was implemented.</p>
<section id="trng-implementation" class="level3">
<h3 class="anchored" data-anchor-id="trng-implementation">TRNG Implementation</h3>
<p>The STM32L432KC MCU has a built in True Random Number Generator (TRNG). The TRNG generates 32 random bits, so we need to read it four times to generate 128 random bits, which equates to a random key that is used for AES-128 encryption. The code is designed so that when the sender sends a message over the website UI, the website calculates how many 128 bit blocks are required to send over the message. The MCU code will then generate a random 128 bit key for each of the message blocks and store it on an array in the MCU to be sent to the sender and receiver FPGA.</p>
</section>
<section id="connection-with-sender-fpga" class="level3">
<h3 class="anchored" data-anchor-id="connection-with-sender-fpga">Connection with Sender FPGA</h3>
<p>The STM32 MCU interacts with the sender FPGA via SPI, which is the same as the way it was set up in lab 7. The data that is sent over to the FPGA is the plaintext and its randomly generated key. Given that our system is built to be able to send multiple 128 bit blocks, we need to know when the FPGA has encrypted a block and is ready to receive the next block and encrypt it. This is achieved by the FPGA sending a done signal to the MCU so that the MCU will send over the next set of plaintext and key. The very first block sending of the program is triggered by the user when hitting the send button on the website, all subsequent block sending is based on the done signal sent by the FPGA.</p>
<p>In terms of hardware, in order to save pins, we will be using the same output pins for the SPI connections between the MCU and both the sender and receiver FPGA. In other words, it means that <code>SCK</code>, <code>COPI</code>, and <code>CIPO</code> are the same MCU pins wired to both FPGAs. In order for the two FPGAs to not read the wrong data, we have a separate chip enable wire going to each of the FPGAs. That way, each FPGA knows when the data sent over SPI is meant for it.</p>
</section>
<section id="esp8266-integration" class="level3">
<h3 class="anchored" data-anchor-id="esp8266-integration">ESP8266 Integration</h3>
<p>The sender MCU uses an ESP8266 for its messaging UI for both the sender and receiver. THe MCU and ESP8266 connect via USART, which is the same as we have done with previous labs. On the sender side, the user will input their desired message. They can then click the convert button, which will show them how many blocks of data are gonna be sent, as well as the data that will be sent. The data will be in hex, which is the ASCII equivalent of the text in hex form, which is what we need to input into the FPGA. Since the FPGA uses AES-128 encryption, we need to ensure that each block of text is 128 bits long, even if the message is not that long. To do this, we can use padding, which will fill the remainder of the 128 bit block. We used PKCS #7 padding, which will fill in the remainding bytes needed in the block with the number of bytes that it is filling in. 128 bit blocks are equivalent to 16 bytes, so if we only use 8 bytes worth of text in the block, it will fill the remaining 8 bytes with 0x08. Then, the user can click send, which will start the whole sending transaction for the system. Below is a sample image of what the website UI looks like for the user:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/senderWeb.png" class="img-fluid figure-img"></p>
<figcaption>Sample Sender Website UI</figcaption>
</figure>
</div>
</section>
<section id="backdoor-connection-to-receiver-fpga" class="level3">
<h3 class="anchored" data-anchor-id="backdoor-connection-to-receiver-fpga">Backdoor Connection to Receiver FPGA</h3>
<p>Since the MCU is generating random keys for each of the blocks of text, the receiver end FPGA needs to know what the keys are to be able to properly decrypt the message. Thus, we need a way for the receiver FPGA to receive this data. We will use SPI to send each of the keys needed, as well as the total number of blocks that the user is sending. The number of blocks is needed, as the MCU will need to know this information to be able to display a progress bar on our LCD and know how much we expect to receive and make progress calculations.</p>
<p>As mentioned previously, this SPI connection shares the same <code>SCK</code>, <code>COPI</code>, and <code>CIPO</code> as with the SPI connection with the sender FPGA. Thus, this FPGA and MCU connection will also have a chip enable, which will tell the FPGA when the MCU is sending data to it.</p>
</section>
</section>
<section id="receiver-mcu-design" class="level2">
<h2 class="anchored" data-anchor-id="receiver-mcu-design">Receiver MCU Design</h2>
<p>For the receiver MCU, it connects with the receiver FPGA for decryption, it connects with the ESP8266 for the receiver end website, it connects with the mechanical actuation system to receive the encrypted ciphertext, and it connects with an LCD display to show live progress of the message transfer.</p>
<section id="connection-with-receiver-fpga" class="level3">
<h3 class="anchored" data-anchor-id="connection-with-receiver-fpga">Connection with Receiver FPGA</h3>
<p>The receiver MCU interacts with the receiver FPGA via SPI, which is the same as the way it was set up in lab 7. The data that is sent over to the FPGA is the encrypted cyphertext that it has received via the mechanical actuation system. The FPGA will then decrypt the data and then send it back to the MCU via SPI, which can then be displayed on the website.</p>
</section>
<section id="esp8266-integration-1" class="level3">
<h3 class="anchored" data-anchor-id="esp8266-integration-1">ESP8266 Integration</h3>
<p>The receiver end ESP8266 displays the decrypted text to the receiver end user, which should match what the sender sent originally. Given that the mechanical system takes a while to send the data, the receiver end website will display one block at a time until all the blocks have arrived to the receiver side and have been decrypted. The receiver end website UI is built to be similar to the sender UI to demonstrate that encryption and decryption worked correctly, showing each individual 128-bit block of data as well as the full message. Below is a sample image of what the receiver end website UI looks like for the user:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/receiverWeb.png" class="img-fluid figure-img"></p>
<figcaption>Sample Receiver Website UI</figcaption>
</figure>
</div>
</section>
<section id="connection-with-mechanical-actuation-system" class="level3">
<h3 class="anchored" data-anchor-id="connection-with-mechanical-actuation-system">Connection with Mechanical Actuation System</h3>
<p>Our mechanical actuation system will be sending data to our receiver MCU via 9 GPIO lines. 8 of them transmit data, and the last one is the clk, so that we can synchronize the incoming data and be able to read it correctly. The receiver end MCU is responsible for reading this data and concatenating each block of data, which will then be sent off to the receiver FPGA for decrytpion.</p>
</section>
<section id="lcd-display-integration" class="level3">
<h3 class="anchored" data-anchor-id="lcd-display-integration">LCD Display Integration</h3>
<p>In order to track how much data has been sent over and how close we are to the full message transaction being complete, we have implemented the use of an LCD Display. We purchased an LCD Display with an I2C adapter, meaning that it will only require 2 MCU pins instead of 8. This saves up a lot of pins, given that the MCU also needs to connect to the ESP8266, the receiver FPGA, and the mechanical actuation system. To drive the LCD display and the I2C adapter, we need a 5V source, which is provided by our motherboard. For the I2C adapter to register a high value, it needs at least <span class="math inline">\(0.7 V_{DD}\)</span>, which is 3.5 V. However, our STM32 pins only output 3.3 V. Thus, we need to use a level shifter, so that the I2C adapter can properly read low and high values. Below is a schematic of our level shifter implementation for our display:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/levelShifter.png" class="img-fluid figure-img"></p>
<figcaption>Schematic for LCD Display with 3.3 V to 5 V Level Shifter</figcaption>
</figure>
</div>
<p>To run the actual display, we were able to use files provided by the manufacturer, which had functions made to control the display. However, this file was in C++, so we had to convert it to C. Once that was done, we were able to initialize I2C on our MCU and display a progress bar on our display. Below is a video demonstrating what the progress tracking would look like:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><video src="images/lcd.mp4" class="img-fluid" controls=""><a href="images/lcd.mp4">Video</a></video></p>
<figcaption>LCD Progress Demo</figcaption>
</figure>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https://rex-josaphat.github.io/MechaCrypt-Portfolio/pages/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>© 2025 <strong>MechaCrypt Project</strong>. All Rights Reserved<br>
Designed and developed by <a href="https://jngoga.vercel.app/" target="_blank"><strong>Josaphat Uwizeye Ngoga</strong></a> &amp; <a href="https://chrwu17.github.io/hmc-e155-portfolio/" target="_blank"><strong>Christian Wu</strong></a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>